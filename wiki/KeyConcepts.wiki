#summary Key Biodiverse concepts - still a work in progress.

<wiki:toc max_depth="4" />

= Key Biodiverse concepts =

This forms a sort of glossary, and perhaps should be named as such.


= Overview =

The key point to keep in mind when using Biodiverse is that it has been developed first for spatial analyses. This includes the Moving Window, Clustering and Randomisations. All of the code has been written under this framework. Any other analysis that can be conducted is in some senses incidental. This does not mean it is invalid, just that it needs to be cast in a spatial framework to run.

= Data structures =

== !BaseData ==

== !BaseStructs ==

=== Elements ===

=== Labels ===

=== Groups ===

== Matrices ==

== Phylogenies ==

= Analyses =

== Clustering ==

== Spatial (moving window) analysis ==

== Randomisations ==

<wiki:comment>
NEED TO EXPLAIN HOW THEY WORK - OVERVIEW
</wiki:comment>

The randomisations do not themselves store any results.  All results are added as additional lists in the spatial and cluster outputs.  They can be accessed under the chooser which defaults to SPATIAL_RESULTS for a spatial analysis and Cluster for a cluster analysis.

There are currently no methods to export the randomisation outputs specifically, but the results can be viewed and exported from the relevant spatial and cluster outputs.  

Assume in this case that _Rand1_ was used as the name of the randomisation (even though we know it is not a good name to use as in three weeks time you will have no idea what it means or was for).

  1. The randomisation results for a spatial analysis go into a list called _Rand1_ on that output. The naming scheme is explained below.  
  1. Cluster analyses (trees) have at least three lists attached to each node, with a fourth if a spatial analysis was conducted on each node. 
    1. _Rand1_ contains summary statistics of the most similar nodes between the original and randomised trees (e.g. mean, median, SD, quartiles, count of comparisons, how many were identical), with the similarity assessed using a Sorenson dissimilarity index (zero is identical, 0.5 means half of the terminal elements across both nodes were shared, with double counting of shared nodes).
    1. _Rand1_DATA_ is the full set of Sorenson comparison results in case you want to extract them for other nefarious purposes (e.g. how many times did the randomisation produce a node which had 80% or more terminal elements in common?).  
    1. _Rand1_ID_LDIFFS_ contains the total lengths (from the tip of the tree) of those nodes that contained an identical set of terminal elements. If all (or most) are longer then the original tree at least has a shorter total length, even though it resulted in the same set of elements being grouped together.  (The name is an abbreviation of IDentical node Length DIFFerences. This is a confusing abbreviation and name, so any suggestions are welcome.)
    1. _Rand1_SPATIAL_ contains the comparison values of the spatial outputs for the most similar nodes. The naming scheme is explained below.  

What do the spatial comparison lists mean? The indices shown are those used in the comparisons, prefixed by a letter with an underscore.

  * C`_*` is the number of times the comparison was higher than the original.
  * Q`_*` (q = quantum) is the number of comparisons. It is counted because there may be cases where undefined values result. We cannot compare undefined with a number, and we also cannot be sure that the number of times undef results is the same for all indices.
  * P`_*` is the fractional ranking, calculated as C`_*` / Q`_*`. Multiply by 100 to get a percentile. The P`_*` score is converted into a p-score in the normal way, e.g. if P`_*` = 0.99 then the original measure is higher than the randomised versions 99 times out of every hundred. If one is interested in higher scores then this is the same as a p score of 0.01. Obviously one changes the interpretation appropriately if it is a two tailed system, eg the mean of numeric labels (NUM_MEAN) can be higher or lower. So long as it is in one of the tails of the distribution then the result is significant (e.g. P_NUM_MEAN < 0.025 or P_NUM_MEAN > 0.975 for an alpha of 0.05).

= Other stuff =

== View Labels columns ==

This is a short definition of the columns visible in the labels part of the View labels tab.  _The columns need to be extended to show the selected set and also any other properties set on import._

=== Variety ===

The number of groups the label occurs in. This is analogous to the range unless one is set separately on import using the _set label remap and properties_ option.

=== Samples ===

The number of times this label occurs across all groups. Groups can have many samples of the same label.  Does not include the value set by the _set label remap and properties_ option.


=== Redundancy ===

The sample redundancy for each label. This is calculated as (1 – variety / samples). A value close to one represents a good overall sample of a label relative to the number of groups it occurs in (many redundant samples). A value of zero means that there is, on average, close to one sample per groups the label occurs in, and it is therefore not well sampled.

== Spatial conditions ==

=== Neighbourhoods ===

These are the set of groups that are are in the neighbouring set of the processing group.  More details are given in the SpatialConditions page.

=== Definition Queries ===

These differ from neighbourhoods as they assess only the processing group to determine if analyses should be calculated for it or not.  They use the same syntax as for neighbourhoods, but the system will commonly complain if a condition involving a neighbouring group is used.

Note that groups that fail the definition query are still considered for membership of neighbour sets of those that pass.  Use in conjunction with an appropriate neighbourhood definition if you want to exclude some groups from neighbour sets as well.  For example, you could use `sp_match_text (axis => 2, text => 'fred', type => 'proc')` for the definition query and `sp_match_text (axis => 2, text => 'fred', type => 'nbr')` for the neighbourhood.  This will restrict calculations to those groups with a third axis of 'fred', and also exclude any group without fred in the third axis from the neighbour sets of those groups processed.

=== Specifying spatial neighbours ===

See the SpatialConditions page.

== Specifying extensions ==

_Need to explain the specification of extensions and how to load them._

== Using the spatial index ==

The spatial index speeds up processing by reducing the number of comparisons that need to be made when assessing if a roup is a neighbour of the processing goup.  Exactly how much of a speed up is a function of the index resolution and the neighbourhood specified (larger neighbourhoods take longer as they use more index blocksand therefore the system must mak more comparisons).

As an example, an analysis of approximately 20,000 groups took ~3600 seconds for a four cell radius neighbourhood without the index. With the index it took 30 seconds. Similarly, one with a radius of one cell took ~3600 seconds without the index and 12 seconds with it.

The reason for the speed-up is that the system no longer needs to assess every other group as a possible neighbour, and instead focuses only on those groups that occur within the indexed blocks that satisfy the spatial condition. Think of the index as a coarse first approximation to the neighbours, with a second search refining the solution to the actual set of neighbours.

Most neighbourhoods one will use are likely to be simple and use the available functions.  In these cases the system can precalculate which ibndex bocks to search.  However, if you are using complex spatial conditions then it must preprocess the data to determine which index groups should be assessed to find neighbours.  This can take some time when usng a fine resolution index, as it must assess each corner of the index extents, and every one of each corner's immediate neighbours, against every other possible index group.  This results in `(m^2 * 3^m * n)` comparisons, where `n` is the number of groups (blocks) in the index and `m` is the number of axes (dimensions) used.  This works out to `4*9n = 36n` for a data set with two group axes.

The system will ignore the spatial index if the spatial conditions used specify it must be ignored.  It can also be turned off if need be using the Analyses->Index menu.


== The ABC lists ==

_Explain ABC, ABC2 and ABC3_
These lists appear in the popup windows. They might look odd at first, and are in some senses left over from the early system development
when most indices depended on some function of A, B and C.

These are based on the fundamental components used for the dissimilarity metrics. *A* is the count of shared labels, 
*B* is the count of labels found only in the first group, *C* is the count found only in the second group. 
*ABC2* also counts how many groups each label occurs in for the set of groups specified, while *ABC3* 
counts the number of samples. *ABC2* is used in endemism calculations, for example, while *ABC3* is used 
for those needing counts, for example redundancy.

== !NoData ==

This will occur in certain analyses when no reasonable value can result, for example where there is a division by zero or 
where there are no valid labels in a neighbourhood, e.g. a matrix analysis was run, but there are no labels in the neighbourhood 
that are listed in the matrix and therefore no value can be assigned that is a function of the matrix.

It is a bad idea to use zero in these cases, as it often has a meaning of its own, for example 0 for a Jaccard dissimilarity 
means the two sets of neighbours are identical.  

Groups with a value of !NoData are plotted as white.  (Black means the group was not included in the analysis, and is typically the case in a cluster analysis if a neighbourhood or definition query is specified).  The !NoData value can be changed on export if needed, and for the raster outputs is set to -9999 by default.

== Scree plot ==

The scree plot below a tree indicates how many nodes occur at each level of, for example, dissimilarity.

== Contrasting colour scheme ==

The contrasting colour scheme is restricted to a maximum of 13 colours, with a different colour scheme used for 9 or fewer. 
The schemes are derived from http://www.colorbrewer.org, but with the addition of a mid-grey to the 12 colour scheme. 
We have experimented with more colours, but found them difficult to distinguish (which is pretty much as recommended 
by the ColorBrewer web site...).

== Selecting nodes ==



== Negative length nodes ==

Negative length nodes (those that go backwards) often occur when using link_recalculate clustering or when switching 
from spatial to non-spatial clustering. In the latter case this is because the two most similar clusters may not be 
within the spatial neighbourhood specified, and so the similarity of the non-spatial clusters will be closer to zero 
than the final spatial clusters. In the former case, the recalculation weights each label equally (for most similarity metrics), 
so the merging of two clusters may actually reduce their joint similarity with the other clusters in the system.

== Cluster Linkages ==

Explain them here.

== File formats and structures ==

The naming system is a “b” for Biodiverse, followed by a letter for the object type, and then an “s” or “y” to denote if it is 
in a Storable or YAML format. The Storable version is preferred, as the YAML format requires more time to parse in and out, 
and also uses more memory. It is, however, useful to interrogate the internal data structure. Note that the YAML format will be 
deprecated as a standard format, but will be supported for export.

BPS/BPY is a Biodiverse project file. This stores a set of !BaseData, Matrix and Phylogeny objects and any display parameters. 
Note that it stores copies of these objects, so changes made to any of the separate or original versions have no effect, and vice versa.

BDS/BDY is a Biodiverse !BaseData object.

BTS/BTY is a Tree object. Generally this is a phylogeny, but can also be a taxonomictree or some other tree-based representation of a hierarchy of relationships.

BMS/BMY is a matrix object.

The BaseData objects and their cluster and spatial outputs contain references to any matrix or phylogeny arguments to enable the randomisations to function effectively. These references mean that copies of the matrices and phylogenies will be stored with the BaseData object if it is exported separately from a project, but will not be visible if the BaseData object is subsequently loaded into a new project.

Note that it is not possible to directly save a cluster result from the GUI because the object needs its links to the parent Biodiverse object.  The reference system used means that the BaseData object will be folded into the tree object thorough its reference, thus making the separation unneccesary and complex to unravel on subsequent import.


== Map overlays ==

Shapefiles only at the moment. They also need to be polyline or polygon. No points, but you could buffer your points by a small 
distance and plot the resulting polygons.

Overlays are available when a map is displayed, for example when viewing labels or displaying the results of a cluster or spatial analysis.

The system currently ignores any vertices that are beyond the bounds of the BaseData groups, so you cannot zoom out any further 
than the BaseData extent.

== Supported file types ==

=== Import ===

BaseData and Matrix objects can import from text files such as CSV or TXT. They currently guess the field separator by default, 
but this can be specified as an argument if guesswork is unsuccessful.

Trees can be imported from Nexus files. NeXML support is planned.

Matrices do not care if the matrix is upper right, lower left, both, or any combination of the above. 
They will store the last defined value for an element pair (reading left to right, top to bottom).

=== Export ===

Spatial and cluster objects can be exported to table formats. Supported formats include text (txt & csv), 
and html table (htm). 

Shapefiles are not supported due to a fatal error in the library we are using, and also due to DBF field name limitations (see below). 
They can generally be recreated from the other formats, though.

Data sets that use square cells and have only two axes can be exported to raster format.  
Currently the system supports Arc/Info asciigrid and floatgrid format, as well as ER-Mapper ERS format.  
To use these just specify an extension of .asc, .flt or .ers respectively.  Note that the first two options 
will produce multiple files with the index name inserted before the file extension 
(e.g., fred.asc can result in `fred_ENDC_CWE.asc` and `fred_ENDC_WE.asc`).  
The ER-Mapper export produces `fred` (the data file) and `fred.ers` (the header file).

Cluster objects can also be exported to the Newick and Nexus formats (Nexus actually uses ontains the Newick format for trees).

_Note:_ The DBF format only allows field names of ten characters.  This is not long enough for many of the index field names so DBF export has been disabled.

_Note:_ If you are exporting an asymmetric array list as a symmetric structure then the system will use the array elements as the field names and insert a 1 in each of the columns where that column element is in the list for that row element. This is because it does not have any values associated with it. If it did then it would be stored as a hash... [needs to be explained better].

== Using the tree exported to a table ==

Need to explain how to use the table, for example in a GIS.



The tree structure as a table allows the storage of the tree's topology in an RDBMS or other structure, including ancillary data 
such as from a spatial analysis run for each node of a cluster tree. These cannot currently be exported using Newick (it should 
be possible using one tree per ancillary variable with the values stored in the bootstrap section, but this is potentially very messy).

== Element property (remap) tables ==

The primary purpose of these is to change names on import so that one data set will properly match another, for example one needs to alter a set of labels in a tree to match those used in a Basedata object, or vice versa.

Note that remapping of labels occurs at the time of import.  Subsequent remapping is not currently supported.

One can also use them to set element properties such as label/group sample counts or label ranges on import. One can also exclude or include on a label or group basis. Note that these are applied before the respective label or group names are remapped.