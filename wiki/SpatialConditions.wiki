#summary How to specify the spatial conditions used to define neighbourhoods and definition queries
#labels Featured

= Introduction =

Spatial conditions are core to the Biodiverse system.  They are used to specify both neighbourhoods used in the analyses, and also the definition queries used to restrict the calculations to some set of groups.  

Neighbourhoods are essential for any spatial analysis, as it is through these that one can define the set of groups to be considered in an analysis.  In the moving window analyses these determine which groups are compared with which other groups.  In the cluster analyses they determine which groups are considered candidates to be clustered together.  It is also possible to define neighbourhoods for spatially constrained randomisatins (see Laffan and Crisp, 2003, J Biogeog), although this is yet to be implemented.

...NEED TO FLESH OUT _Can be based on location relative to the processing group, but also some other aspect of the system such as the value of a text group (eg using `sp_match_text`)_


As with any system, there must be compromises between ease of use and system flexibility. In this case we have gone for system flexibility by direct use of Perl syntax. This means you can use arbitrarily complex functions to define neighbourhoods, including loops and other multiple variable conditions. This may be horrifying to non-perlers, as one of the main complaints about perl is its complex grammar and syntax. To alleviate this somewhat, we have provided examples below of some of the basic approaches one might want to use.

The neighbourhood and definition query interfaces have a syntax verification button to check that the syntax is valid. This does not, however, guarantee your parameters will work, only that it is valid Perl code. (The reality here is that we will just evaluate the parameter statement with some default values and warn you if the system raises some sort of exception).

=== Functions ===

Functions are the easiest way to specify conditions as one does not need to wrestle with variables.  Functions also set metadata to tell the system whether, and how to, to use the spatial index.  This saves considerable processing time for large data sets as the system does not need to test many pairs of index groups (see KeyConcepts#Using_the_spatial_index).

_Note: Need to list the available functions, eg sp_circle, sp_ellipse, sp_block, sp_match_text, sp_select_sequence. Should really develop an auto-generated file for them so we can list the args from the metadata (like with the analyses).  This should also be part of the GUI - see issue #14._

=== Variables ===

There are several different sets of variables implemented that the system recognises. Any undeclared variable you use that does not occur in this list will be treated as a zero or as undefined (depending on where it is used), which means it will probably not behave as you expect. An example declaring variables is given below.

As a general rule, uppercase letters denote absolute values, lower case letters denote signed values (positive or negative). Positive values are north, east, above, or to the right. Negative values are south, west, below or to the left.

A group is considered a neighbour of the central group if the condition evaluates to true. The central group is whichever one is being processed at the time (remember that these are evaluated for all groups in a spatial analysis).

`$D` is the absolute euclidean distance across all dimensions.

`$D[0]`, `$D[1]` are the absolute euclidean distance in dimension 0 and 1. In most cases `$D[0]` will be the X (longitude) dimension, `$D[1]` will be the Y (latitude) dimension. The library functions can actually handle more dimensions than this (eg `$D[2]` for altitude or depth), but the GUI is not set up to display them.

`$d[0]`, `$d[1]` and so forth are the signed euclidean distance in dimension 0, 1 etc. This allows us to extract all groups within some distance in some direction. As with standard Cartesian plots, negative values are to the left or below (west or south), positive values to the right or above (east or north). As with `$D[0]`, `$d[0]` will normally be the X dimension, `$d[1]` will be the y dimension.

Note that using `abs($d[1])` is the same as using `$D[1]`.

`$C`, `$C[0]`, `$C[1]`, `$c[0]`, `$c[1]` are the same as the euclidean distance variables (`$D` etc) but operate directly in group (cell) units. If your groups were imported using a cellsize of 100,000, then `$D[1] < 100000` is the same as `$C[1] < 1`. Note, however, that if you used a different resolution in each dimension, then the euclidean and cell distances are not directly comparable.

`$coord[0]`, `$coord[1]` are the coordinate values in the first and second dimension. As per the above, think of these as X and Y, except that `$coord[5]` will also work if you have that many dimensions. Note that this does not work properly when the spatial index is being used.

=== Examples ===

  * Set the neighbours to be those groups where the absolute distance from the central group is less than 100,000.

{{{
$D <= 100000
}}}

  * Select all groups to the west of the central group.

{{{
$d[0] < 0
}}}

  * Select all groups to the north-east of the central group.

{{{
$d[0] > 0 && $d[1] > 0
}}}

  * The absolute distance in the first (eg x) dimension is less than 100,000 AND the signed distance is greater than 100,000. This will result in a neighbourhood that is a column of groups 200,000 map units east-west, and including all groups 100,000 map units north of the central group. Not that you would normally want a neighbourhood like this...

{{{
$D[0] <= 100000 && $d[1] >= 100000
}}}

=== Declaring variables and using more complex functions. ===

Variable declaration is done as per perl syntax. For example:

{{{
$my_var = 10;

($D / $my_var) <= 100
}}}

This trivial example evaluates to true if the absolute distance divided by 10 (the value in variable $my_var) is less than 100. The semicolon denotes a separation of statements to be processed in sequence, such that this example could be written on one line. The result of the last statement is what is returned to the analysis to determine if the group is part of the neighbourhood or not. It is evaluated as true or false.

A more complex function might involve an ellipse (although you could just use `sp_ellipse (major_radius => 300000, minor_radius => 100000)`):

{{{
my $major_radius = 300000; # longest axis

my $minor_radius = 100000; # shortest axis

# set the offset in radians, anticlockwise (1.57 is north)

my $rotate_angle = 1.57;

# now calc the bearing to rotate the coords by

my $bearing = atan2 ($d[0], $d[1]) + $rotate_angle;

my $r_x = cos ($bearing) * $D; # rotated x coord

my $r_y = sin ($bearing) * $D; # rotated y coord

my $a = ($r_y ** 2) / ($major_radius ** 2);

my $b = ($r_x ** 2) / ($minor_radius ** 2);

# this last line evaluates to 1 (true) if the candidate
# neighbour is within the ellipse

return 1 >= ($a + $b);
}}}


Note the use of the word "my". This is required to declare your own variables in the correct scope. If it is not used then the variables will not work properly. Do not declare any of the pre-calculated Biodiverse variables with this (`$D` etc) - they already exist and redeclaring will overprint them.

Initial tests indicate that this function works with the spatial index, but test your own data to be sure. Run an analysis with and without the spatial index, using the Element Lists analysis to get the lists of neighbours. Export the results to CSV and use a difference tool to compare the results.

Functions available by default are those in the POSIX library. Look in the perl help files to see a listing of what is there. If you want more then you will need to specify additional libraries in the extensions file under the BaseData section. _NEED TO IMPLEMENT HELP FOR THIS_.

To access environment variables you have set, just use `$ENV{variable_name}`, eg `$ENV{my_default_radius}`.